## 零、开局

前两天我搞了两个每日一个知识点，对多线程的部分知识做了下概括性的总结。但通过小伙伴的反馈是，那玩意写的比较抽象，看的云里雾里晕晕乎乎的。所以又针对多线程底层这一块再重新做下系统性的讲解。有兴趣的朋友可以先看下前两节，可以说是个笼统的概念版。

好了，回归正题。在多线程的世界里synchronized、volatile、JMM是我们绕不过去的技术坎，而重排序、可见性、内存屏障又有时候搞得你一脸懵逼。有道是知其然知其所以然，了解了底层的原理性问题，不论是日常写BUG还是面试都是必备神器了。

 

**先看几个问题点：**

1、处理器与内存之间是怎么交互的？

2、什么是缓存一致性协议？

3、高速缓存内的消息是怎么更新变化的？

4、内存屏障又和他们有什么关系？



如果上面的问题你都能倒背如流，那就去看看电影放松下吧！





## 一、高速缓存

目前的处理器的处理能力要远远的胜于主内存（DRAM）访问的效率，往往主内存执行一次读写操作所需的时间足够处理器执行上百次指令。所以为了填补处理器与主内存之间的差距，设计者们在主内存和处理器直接引入了高速缓存（Cache）。如图：

<img src="/Users/luqiang/Downloads/公众号图片/多线程硬件基础/Xnip2020-09-29_21-57-22.jpg" style="zoom:50%;" />





其实在现代处理器中，会有多级高速缓存。一般我们会成为一级缓存（L1 Cache）、二级缓存（L2 Cache）、三级缓存（L3 Cache）等，其中一级缓存一般会被集成在CPU内核中。如图：

<img src="/Users/luqiang/Downloads/公众号图片/多线程硬件基础/高速缓存.png" alt="高速缓存" style="zoom:50%;" />

#### 内部结构

高速缓存存在于每个处理器内，处理器在执行读、写操作的时候并不需要直接与内存交互，而是通过高速缓存进行。

高速缓存内其实就是为应用程序访问的变量保存了一个数据副本。高速缓存相当于一个容量极小的散列表（Hash Table），其键是一个内存地址，值是内存数据的副本或是我们准备写入的数据。从其内部来看，其实相当于一个拉链散列表，也就是包含了很多桶，每个桶上又可以包含很多缓存条目（想想HashMap），如图：

<img src="/Users/luqiang/Downloads/公众号图片/多线程硬件基础/高速缓存结构.jpg" alt="高速缓存结构" style="zoom:50%;" />



#### 缓存条目

在每个缓存条目中，其实又包含了Tag、Data Block、Flag三个部分，咱们来个小图：

<img src="/Users/luqiang/Downloads/公众号图片/多线程硬件基础/缓存条目.jpg" alt="缓存条目" style="zoom:50%;" />





- **Data Block : **也就是我们常常叨叨的缓存行（Cache Line）,她其实是高速缓存与主内存间进行数据交互的最小单元，里面存储着我们需要的变量数据。
- **Tag : **包含了缓存行中数据内存地址的信息（其实是内存地址的高位部分的比特）

- **Flag :** 标识了当前缓存行的状态（MESI咯）





**那么，我们的处理器又是怎么寻找到我们需要的变量呢？**



不多说，上图：

<img src="/Users/luqiang/Downloads/公众号图片/多线程硬件基础/查询值.jpg" alt="查询值" style="zoom:50%;" />

其实，在处理器执行内存访问变量的操作时，会对内存地址进行解码的(由高速缓存控制器执行)。而解码后就会得到tag、index 、offset三部分数据。

**index : **我们知道高速缓存内的结构是一个拉链散列表，所以index就是为了帮我们来定位到底是哪个缓存条目的。

**tag : ** 很明显和我们缓存条目中的Tag 一样，所以tag 相当于缓存条目的编号。主要用于，在同一个桶下的拉链中来寻找我们的目标。

**offset : ** 我们要知道一个前提，就是一个缓存条目中的缓存行是可以存储很多变量的，所以offset的作用是用来确定一个变量在缓存行中的起始位置。

所以，在如果在高速缓存内能找到缓存条目并且定位到了响应得缓存行，而此时缓存条目的Flag标识为有效状态，这时候也就是我们所说的缓存命中（Cache Hit）,否则就是缓存未命中（Cache Miss）。



 缓存未命有包括读未命中（Read Miss）和写未命中(Write Miss)两种,对应着对内存的读写操作。

**而在读未命中（Read Miss）**产生时，处理器所需要的数据会从主内存加载并被存入高速缓存对应的缓存行中，此过程会导致处理器停顿（Stall）而不能执行其他指令。



## 二、缓存一致性协议 

在多线程进行共享变量访问时，因为各个线程执行的处理器上的高速缓存中都会保存一份变量的副本数据，这样就会有一个问题，那当一个副本更新后怎么保证其它处理器能马上的获取到最新的数据。这其实就是缓存一致性的问题，其本质也就是怎么防止数据的脏读。

为了解决这个问题，处理器间出现了一种通信机制，也就是缓存一致性协议（Cache Coherence Protocol）。



#### MESI是什么

缓存一致性协议有很多种，MESI（Modified-Exclusive-Shared-Invalid）协议其实是目前使用很广泛的缓存一致性协议，x86处理器所使用的缓存一致性协议就是基于MESI的。

我们可以把MESI对内存数据访问理解成我们常用的读写锁，它可以使对同一内存地址的读操作是并发的，而写操作是独占的。所以在任何时刻写操作只能有一个处理器执行。而在MESI中，一个处理器要向内存写数据时必须持有该数据的所有权。



MESI将缓存条目的状态分为了Modified、Exclusive、Shared、Invalid四种，并在此基础上定义了一组消息用于处理器的读、写内存操作。如图：

<img src="/Users/luqiang/Downloads/公众号图片/多线程硬件基础/mesi.jpg" alt="mesi" style="zoom:50%;" />



#### MESI的四种状态

所以MESI其实就是使用四种状态来标识了缓存条目当前的状态，来保证了高速缓存内数据一致性的问题。那我们来仔细的看下四种状态

**Modified ：**

表示高速缓存中相应的缓存行内的数据已经被更新了。由于MESI协议中任意时刻只能有一个处理器对同一内存地址对应的数据进行更新，也就是说再多个处理器的高速缓存中相同Tag值得缓存条目只能有一个处于Modified状态。处于此状态的缓存条目中缓存行内的数据与主内存包含的数据不一致。



**Exclusive：**

表示高速缓存相应的缓存行内的数据副本与主内存中的数据一样。并且，该缓存行以独占的方式保留了相应主内存地址的数据副本，此时其他处理上高速缓存当前都不保留该数据的有效副本。



**Shared：**

表示当前高速缓存相应缓存行包含相应主内存地址对应的数据副本，且与主内存中的数据是一致的。如果缓存条目状态是Shared的，那么其他处理器上如果也存在相同Tag的缓存条目，那这些缓存条目状态肯定也是Shared。



**Invalid：**

表示该缓存行中不包含任何主内存中的有效数据副本，这个状态也是缓存条目的初始状态。



#### MESI处理机制

前面说了那么多，都是MESI的基础理论，那么，MESI协议到底是怎么来协调处理器进行内存的读写呢？



<img src="/Users/luqiang/Downloads/公众号图片/多线程硬件基础/mesi机制.jpg" alt="mesi机制" style="zoom:50%;" />

其实，想协调处理必然需要先和各个处理器进行通信。所以MESI协议定义了一组消息机制用于协调各个处理器的读写操作。

我们可以参考HTTP协议来进行理解，可以将MESI协议中的消息分为请求和响应两类。处理器在进行主内存读写的时候会往总线（Bus）中发请求消息，同时每个处理器还会嗅探（Snoop）总线中由其他处理器发出的请求消息并在一定条件下往总线中回复响应得响应消息。



针对于消息的类型，有如下几种：

- **Read : **请求消息，用于通知其他处理器、主内存，当前处理器准备读取某个数据。该消息内包含待读取数据的主内存地址。



- **Read Response: **响应消息，该消息内包含了被请求读取的数据。该消息可能是主内存返回的，也可能是其他高速缓存嗅探到Read 消息返回的。



- **Invalidate：**请求消息，通知其他处理器删除指定内存地址的数据副本。其实就是告诉他们你这个缓存条目内的数据无效了，删除只是逻辑上的，其实就是更新下缓存条目的Flag.



- **Invalidate Acknowledge：**响应消息，接收到Invalidate消息的处理器必须回复此消息，表示已经删除了其高速缓存内对应的数据副本。



-  **Read Invalidate:  **请求消息，此消息为Read 和 Invalidate消息组成的复合消息，作用主要是用于通知其他处理器当前处理器准备更新一个数据了，并请求其他处理器删除其高速缓存内对应的数据副本。接收到该消息的处理器必须回复Read Response 和 Invalidate Acknowledge消息。



- **Writeback: **请求消息，消息包含了需要写入主内存的数据和其对应的内存地址。



**了解完了基础的消息类型，那么我们就来看看MESI协议是如何协助处理器实现内存读写的，看图说话：**

举例：假如内存地址0xxx上的变量s 是CPU1 和CPU2共享的**我们先来说下CPU上读取数据s**



**高速缓存内存在有效数据时：**

<img src="/Users/luqiang/Downloads/公众号图片/多线程硬件基础/读数据.jpg" alt="读数据" style="zoom:50%;" />

CPU1会根据内存地址0xxx在高速缓存找到对应的缓存条目，并读取缓存条目的Tag和Flag值。如果此时缓存条目的Flag 是M、E、S三种状态的任何一种，那么就直接从缓存行中读取地址0xxx对应的数据，不会向总线中发送任何消息。



**高速缓存内不存在有效数据时：**

<img src="/Users/luqiang/Downloads/公众号图片/多线程硬件基础/读数据01.jpg" alt="读数据01" style="zoom:50%;" />



1、如CPU2 高速缓存内找到的缓存条目状态为I时，则说明此时CPU2的高速缓存中不包含数据s的有效数据副本。

2、CPU2向总线发送Read消息来读取地址0xxx对应的数据s.

3、CPU1（或主内存）嗅探到Read消息，则需要回复Read Response提供相应的数据。

4、CPU2接收到Read Response消息时，会将其中携带的数据s存入相应的缓存行并将对应的缓存条目状态更新为S。



**从宏观的角度看，就是上面的流程了，我们再继续深入下，看看在缓存条目为I的时候到底是怎么进行消息处理的**



<img src="/Users/luqiang/Downloads/公众号图片/多线程硬件基础/读取流程图.jpg" alt="读取流程图" style="zoom:50%;" />





**说完了读取数据，我们就在说下CPU1是怎么写入一个地址为0xxx的数据s的**

<img src="/Users/luqiang/Downloads/公众号图片/多线程硬件基础/写数据.jpg" alt="写数据" style="zoom:50%;" />



MESI协议解决了缓存一致性的问题，但其中有一个问题，那就是需要在等待其他处理器全部回复后才能进行下一步操作，这种等待明显是不能接受的。



## 三、写缓冲和无效化队列

