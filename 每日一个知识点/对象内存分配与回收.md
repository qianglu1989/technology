> 每日一个知识点系列的目的是针对某一个知识点进行概括性总结，可在一分钟内完成知识点的阅读理解，此处不涉及详细的原理性解读，只作为一种抛砖引玉。真正的理解一定是你自我研究探索所收获的知识。



1、大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。虚拟机提供-XX：+PrintGCDetails参数可打印内存回收日志。



2、大对象直接进入老年代

大对象就是指需要大量连续内存空间的Java对象，最典型的大对象便是那种很长的字符串，或者元素数量很庞大的数组。

开发中要避免“朝生夕灭”的“短命大对象”，原因就是在分配空间时，它容易导致内存明明还有不少空间时就提前触发垃圾收集，以获取足够的连续空间才能安置好它们，而当复制对象时，大对象就意味着高额的内存复制开销。

使用-XX：PretenureSizeThreshold参数指定大于该值的对象直接在老年代分配（只对Serial和ParNew有效）。这样做的目的就是避免在Eden区及两个Survivor区之间来回复制，产生大量的内存复制操作。



3、长期存活的对象将进入老年代

对象在Eden中每经过一次Minor GC后仍然存活，并且Survivor空间足够的话就会被移动到Survivor空间中，并将对象年龄加一（对象年龄在对像头中），当到达一定年龄（默认15）就会晋升到老年代，可以通过参数-XX：MaxTenuringThreshold设置。



4、动态对象年龄判定

如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到15次Minor GC。



5、空间分配担保

在Minor GC前虚拟机会去先检查老年代的最大可用连续空间是否大于新生代所有对象总空间。

如果大于，那此次Minor GC保证是安全的。

如果小于新生代对象和，那就会去查看-XX：HandlePromotionFailure设置是不是允许担保失败。

如果允许，就会继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小。

如果大于，就会尝试进行下Minor GC

如果小于或者-XX：HandlePromotionFailure 为false那就直接进行Full GC 

 

